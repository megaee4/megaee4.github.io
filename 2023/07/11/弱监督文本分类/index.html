<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/180.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="实验题目设计并实现一个弱监督文本分类模型。  我们只有类的名称，类的关键词和大量无标签的文本。 在进阶任务中，我们删去了一些类的名称和关键词，我们需要实现识别未知类别。  实验内容算法原理弱监督学习在有监督学习中，模型从带标签的数据中进行学习；在无监督学习中，模型从不带标签的数据中学习。弱监督学习可以说是结合了这两者。在弱监督学习中，我们拥有极少的带标签数据（或者是关于数据的一些先验知识）与较多的">
<meta property="og:type" content="article">
<meta property="og:title" content="弱监督文本分类">
<meta property="og:url" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/index.html">
<meta property="og:site_name" content="Megaee的小屋">
<meta property="og:description" content="实验题目设计并实现一个弱监督文本分类模型。  我们只有类的名称，类的关键词和大量无标签的文本。 在进阶任务中，我们删去了一些类的名称和关键词，我们需要实现识别未知类别。  实验内容算法原理弱监督学习在有监督学习中，模型从带标签的数据中进行学习；在无监督学习中，模型从不带标签的数据中学习。弱监督学习可以说是结合了这两者。在弱监督学习中，我们拥有极少的带标签数据（或者是关于数据的一些先验知识）与较多的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/alg.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse2.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse1.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse3.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse4.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pseall1.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pseall2.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mata.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/matb.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/matcnt.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mat2_unk.png">
<meta property="og:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mat1_unk.png">
<meta property="article:published_time" content="2023-07-11T02:14:50.000Z">
<meta property="article:modified_time" content="2023-07-11T02:44:41.212Z">
<meta property="article:author" content="Megaee">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/alg.png">


<link rel="canonical" href="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/","path":"2023/07/11/弱监督文本分类/","title":"弱监督文本分类"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>弱监督文本分类 | Megaee的小屋</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Megaee的小屋</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我，再生产！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E9%A2%98%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">实验题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">实验内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">算法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="nav-number">2.1.1.</span> <span class="nav-text">弱监督学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">自训练算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BE%97%E5%88%B0%E2%80%9C%E4%BC%AA%E6%A0%87%E7%AD%BE%E2%80%9D"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">如何从关键词得到“伪标签”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E5%8F%96%E5%88%86%E7%B1%BB%E5%99%A8"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">如何选取分类器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E8%AE%AD%E7%BB%83%E9%9B%86"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">如何扩展训练集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">2.1.3.</span> <span class="nav-text">评价指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">混淆矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E7%A1%AE%E7%8E%87"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">准确率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B2%BE%E7%A1%AE%E7%8E%87"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">精确率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AC%E5%9B%9E%E7%8E%87"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">召回率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#f1-score"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">f1_score</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E7%9F%A5%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="nav-number">2.1.4.</span> <span class="nav-text">未知类型识别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%90%91%E9%87%8F"><span class="nav-number">2.1.5.</span> <span class="nav-text">文本向量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bag-of-Words"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">Bag-of-Words</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TF-IDF"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">TF-IDF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="nav-number">2.1.6.</span> <span class="nav-text">逻辑回归</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">正则化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CNN"><span class="nav-number">2.1.7.</span> <span class="nav-text">CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">卷积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReLU"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">ReLU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%A0%E5%8C%96"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">池化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">全连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="nav-number">2.1.7.5.</span> <span class="nav-text">优化器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.7.6.</span> <span class="nav-text">损失函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="nav-number">2.2.</span> <span class="nav-text">关键代码展示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E6%96%B0%E7%82%B9"><span class="nav-number">2.2.1.</span> <span class="nav-text">创新点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%B8%8E%E5%B1%95%E7%A4%BA"><span class="nav-number">3.</span> <span class="nav-text">实验结果与展示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95-1"><span class="nav-number">3.1.</span> <span class="nav-text">自训练算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E7%9F%A5%E7%B1%BB%E5%88%AB%E8%AF%86%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">未知类别识别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Megaee"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Megaee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/megaee4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;megaee4" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1942064163&auto=1&height=66"></iframe>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Megaee">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Megaee的小屋">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="弱监督文本分类 | Megaee的小屋">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          弱监督文本分类
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-07-11 10:14:50 / Modified: 10:44:41" itemprop="dateCreated datePublished" datetime="2023-07-11T10:14:50+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Artificial-Intelligence/" itemprop="url" rel="index"><span itemprop="name">Artificial Intelligence</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>设计并实现一个弱监督文本分类模型。</p>
<ul>
<li>我们只有类的名称，类的关键词和大量无标签的文本。</li>
<li>在进阶任务中，我们删去了一些类的名称和关键词，我们需要实现识别未知类别。</li>
</ul>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><h4 id="弱监督学习"><a href="#弱监督学习" class="headerlink" title="弱监督学习"></a>弱监督学习</h4><p>在有监督学习中，模型从带标签的数据中进行学习；在无监督学习中，模型从不带标签的数据中学习。弱监督学习可以说是结合了这两者。在弱监督学习中，我们拥有极少的带标签数据（或者是关于数据的一些先验知识）与较多的无标签数据，模型需要从这些数据中进行学习。</p>
<p>弱监督学习的优点是，只需要较少的标签数据，降低了人工标注的成本和工作量，并在标注数据有限的情况下仍能获得良好的学习性能。但是，这也会产生一些难以避免的问题，例如准确率较低，模型过拟合等。</p>
<p>本次实验就是一个弱监督学习的任务。在本次实验中，我们拥有的数据是类的名称和对应的关键词，以及大量无标签的文本数据，要求我们实现一个弱监督文本分类器。</p>
<h4 id="自训练算法"><a href="#自训练算法" class="headerlink" title="自训练算法"></a>自训练算法</h4><p>自训练算法是一种半监督学习的方法，用于处理只有部分标注数据的情况。在自训练算法中，初始的标注数据集作为训练集训练一个初始模型，然后该模型用于对未标注数据进行预测，并将预测结果作为伪标签加入到训练集中，形成一个更大的训练集。接下来，使用这个扩充后的训练集集重新训练模型，重复这个过程多次。</p>
<p>自训练算法的基本步骤如下：</p>
<ol>
<li>使用初始标注数据集训练一个初始模型。</li>
<li>使用该模型对未标注数据进行预测，并将预测结果作为伪标签。</li>
<li>将已标注数据集和置信度较高的加入的伪标签组合成一个训练集。</li>
<li>使用扩充后的训练集重新训练模型。</li>
<li>重复步骤2至4直到满足停止条件（例如达到最大迭代次数或模型性能收敛）。</li>
</ol>
<p>自训练算法的关键在于如何选择哪些未标注数据的预测结果可以被可靠地加入到已标注数据集中。通常使用一定的置信度阈值来筛选预测结果，并且对于置信度较高的样本才进行标记扩充，以尽量减少伪标签引入的噪声。</p>
<h5 id="如何从关键词得到“伪标签”"><a href="#如何从关键词得到“伪标签”" class="headerlink" title="如何从关键词得到“伪标签”"></a>如何从关键词得到“伪标签”</h5><p>笔者提出了三种方案：</p>
<ol>
<li><p>如果文本中存在某一类别的关键词，就将该文本归为此类；</p>
</li>
<li><p>统计文本中某一类别的关键词数量，将其预测为关键词数量最多的类，在方案 1 的基础上做了一些补充；</p>
</li>
<li><p>将关键词作为初始的训练集，直接用于训练分类器，利用该分类器对所有文本分类，将置信度较高样本的作为下一次训练的训练集。</p>
</li>
</ol>
<p>1 与 2 都不涉及分类模型，只能标注部分词，而 3 是对所有的数据都进行了标注，但方案 3 对那些没有关键词存在的文本分类效果也是很差的。</p>
<h5 id="如何选取分类器"><a href="#如何选取分类器" class="headerlink" title="如何选取分类器"></a>如何选取分类器</h5><p>我们尝试了不同分类器在本次任务中的分类效果。在传统的机器学习方法中，我们选择了逻辑回归；在深度学习的方法中，我们选择了 CNN。但是由于 CNN 结构复杂，参数相对较多，训练时间相对较长，我在 CNN 上花的时间相对较少。</p>
<h5 id="如何扩展训练集"><a href="#如何扩展训练集" class="headerlink" title="如何扩展训练集"></a>如何扩展训练集</h5><p>根据课件中介绍的算法，我们需要在“伪标签”数据中选择 M 个置信度最高的样本加入训练集。然而在实际情况中，这个 M 是不好取的。</p>
<ul>
<li>M 过小，会导致模型的泛化性不好，模型容易出现过拟合。</li>
<li>M 过大，会导致每次选取的“伪标签”数据中，预测错误的数据增加，训练集的质量下降。</li>
<li>即使 M 在训练中的某个时刻取得了一个合适的值，它可能会随着训练集的增大而变得不合适。举例来说，向 10 个数据中加入 1 个数据，与向 1000 个数据中加入 1 个数据，所带来的影响肯定是不同的。</li>
</ul>
<p>于是笔者考虑将 M 取为一个等差数列，在训练过程中不断增大 M 的值。</p>
<p>我们也可以换一种方法，用置信度作为数据是否加入训练集的指标。这时我们需要确定一个阈值，将所有预测置信度大于该阈值的数据加入到训练集。同样地，根据我们上面的讨论，这个阈值也是要随着训练不断增大的。</p>
<p>整个自训练过程的框架如下：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\alg.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/alg.png" class="" title="这是一张图片">

<h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><p>我们介绍几种在分类任务中可以使用的评价指标。</p>
<h5 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h5><p>在二分类问题中，我们将分类结果分为 4 类：</p>
<ul>
<li>TP（真正例）：模型正确地将正例样本分类为正例。</li>
<li>TN（真负例）：模型正确地将反例样本分类为负例。</li>
<li>FP（假正例）：模型错误地将反例样本分类为正例。</li>
<li>FN（假负例）：模型错误地将正例样本分类为负例。</li>
</ul>
<p>如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">预测为正例</th>
<th align="center">预测为负例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>实际为正例</strong></td>
<td align="center">TP</td>
<td align="center">FN</td>
</tr>
<tr>
<td align="center"><strong>实际为负例</strong></td>
<td align="center">FP</td>
<td align="center">TN</td>
</tr>
</tbody></table>
<p>多分类问题的混淆矩阵是类似的，$Mat[i,j]$ 上的元素表示实际属于类别 i 的样本被预测为 j 的数量。可以发现矩阵对角线上的元素就表示了模型正确分类的样本数。</p>
<h5 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h5><p>准确率就是模型分类正确的比例。在混淆矩阵中，其等于对角线元素之和/所有元素之和。在二分类任务中：<br>$$<br>Acc=\dfrac{TP+TN}{TP+FN+FP+TN}<br>$$</p>
<h5 id="精确率"><a href="#精确率" class="headerlink" title="精确率"></a>精确率</h5><p>在二分类任务中，精确率指的是模型预测为正的样本中实际为正的比例。<br>$$<br>P=\dfrac{TP}{TP+FP}<br>$$</p>
<h5 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h5><p>在二分类任务中，召回率指的是实际为正的样本中被预测为正的比例。<br>$$<br>R=\dfrac{TP}{TP+FN}<br>$$</p>
<h5 id="f1-score"><a href="#f1-score" class="headerlink" title="f1_score"></a>f1_score</h5><p>在二分类任务中，f1_score 是精确率与召回率的调和平均。<br>$$<br>F_1=2\dfrac{P\times R}{P+R}<br>$$<br>对于多分类任务，我们可以使用 macro-f1。对于每个类别，分别计算该类别的 F1 分数，随后求平均得到 macro-f1。</p>
<h4 id="未知类型识别"><a href="#未知类型识别" class="headerlink" title="未知类型识别"></a>未知类型识别</h4><p>在进阶任务中，我们删去了一些类的名称和关键词，需要实现识别未知类别。</p>
<p>课件上给出了三种方法：</p>
<ul>
<li>基于置信度，将置信度小于某个值的预测为未知类别</li>
<li>若预测到每个类的概率类似，预测为未知类别</li>
<li>基于熵拒绝</li>
</ul>
<p>这里我们在实现时，使用的是基于置信度的拒绝方法。</p>
<p>下面是一些关于文本分类与分类器的原理。</p>
<blockquote>
<p>这一部分很多都是复用以前的报告。</p>
</blockquote>
<h4 id="文本向量"><a href="#文本向量" class="headerlink" title="文本向量"></a>文本向量</h4><p>首先我们需要将文本转换为向量，作为分类器的输入。</p>
<h5 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag-of-Words"></a>Bag-of-Words</h5><p>Bag-of-Words 考虑单词出现的次数，向量的每一维度的值表示该维度表示的单词在文档中出现的次数。</p>
<h5 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h5><p>我们用 $TF$ 表示词频归一化的概率，$IDF$ 表示逆向文档频率。$IDF$ 的计算公式如下：<br>$$<br>IDF_{x_i}=\log\dfrac{N}{1+n(x_i)}<br>$$<br>其中 $N$ 为文档总数，$n(x_i)$ 为出现了单词 $x_i$ 的文档总数。</p>
<p>于是我们的 $TFIDF=TF\times IDF$。</p>
<h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>在二元逻辑回归中，我们使用 sigmoid 函数：<br>$$<br>y = \dfrac{1}{1+e^{-z}}<br>$$<br>对 $z=\mathbf{W}^\mathrm T\mathbf{x}$进行激活。这样保证了输出 $y\in(0,1)$，我们就可以将 $y$ 看作一个概率值。</p>
<p>在多元逻辑回归中，我们使用 softmax 函数：<br>$$<br>y(z_i)=\dfrac{e^{z_i}}{\sum_{k=1}^{n}e^{z_k}}<br>$$<br>对 $z_i=\mathbf{W}_i^\mathrm{T}\mathbf{x}$ 进行激活。这样我们就将一个类的线性的输出转换为了其被分为这个类的概率。随后我们可以选择概率最大的类别作为预测结果。</p>
<p>在训练过程中，我们需要使用极大似然估计法，用负的对数似然函数作为损失函数，随后使用优化算法（如梯度下降）学习参数。</p>
<h5 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h5><p>L1 正则化和 L2 正则化是逻辑回归中常用的两种正则化方法。L1 正则化通过在损失函数中增加 L1 范数来惩罚模型的系数 $\mathbf{W}$，而 L2 正则化选择在损失函数中增加 L2 范数。<br>$$<br>L_1=\sum|w_i|\quad L_2=\sum w_i^2<br>$$<br>这样能够在一定程度上减少过拟合现象。</p>
<h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>一个最简单的卷积神经网络通常包含以下几层：</p>
<ul>
<li>卷积层</li>
<li>ReLU 层</li>
<li>池化层</li>
<li>全连接层</li>
</ul>
<h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>在 CNN 中，我们的卷积运算定义为：<br>$$<br>y_{i,j}=\sum_{u=1}^m\sum_{v=1}^nw_{u,v}\times x_{i-u+1,j-v+1}<br>$$<br>通过这样的卷积运算，我们可以将一个高维度的矩阵映射为一个低维度的矩阵，从而显著减少神经网络中的参数数量。</p>
<h5 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h5><p>ReLU 函数定义如下：<br>$$<br>f(x)=\max(0,x)<br>$$<br>ReLU 函数在卷积神经网络中是一种激活函数。该函数的主要优点是收敛速度快，易于求梯度。</p>
<h5 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h5><p>池化操作用于对输入特征进行下采样，进一步筛选特征，减少参数数量，增强模型的鲁棒性。常用的池化操作是最大池化，该操作是在特定区域中取出特征图中的最大值作为输出，一般取池化区域为 $2\times 2$，步长为 $2$。</p>
<h5 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h5><p>全连接层是一个线性层，通常出现在卷积神经网络的尾部，连接方式与其在传统的神经网络中一致，与上一层的所有神经元相连，用来综合前面提取的特征，输出分类或回归的结果。</p>
<p>流程图如下：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\lab6\ori.png) -->


<h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>通常我们称更新参数的算法为优化器。</p>
<p>在这里我们使用的优化器主要是 SGD 与 Adam。</p>
<ul>
<li><p>SGD 是随机梯度下降法。我们记需要优化的参数为 $w$，损失函数为 $L$，学习率为 $\eta$ 则 SGD 算法更新参数的公式为：<br>$$<br>w=w-\eta\dfrac{\partial L}{\partial w}<br>$$<br>该算法计算简单，易于实现，但是容易陷入局部最优解。</p>
</li>
<li><p>Adam 是自适应矩估计法。在 Adam 中，我们引入动量的概念。首先是一阶动量：<br>$$<br>m_t=\beta_1m_{t-1}+(1-\beta_1)g_t<br>$$<br>其中 $g_t=\dfrac{\partial L}{\partial w}$。同样还有二阶动量：<br>$$<br>v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2<br>$$<br>我们对 $m_t$ 与 $v_t$ 进行偏差校正：<br>$$<br>\begin{aligned}<br>\hat{m_t}&amp;=\dfrac{m_t}{1-\beta_1^t}\\<br>\hat{v_t}&amp;=\dfrac{v_t}{1-\beta_2^t}<br>\end{aligned}<br>$$</p>
</li>
</ul>
<p>  于是 Adam 更新参数的公式如下：<br>$$<br>  w=w-\eta\dfrac{\hat {m_t}}{\sqrt{\hat {v_t}}+\epsilon}<br>$$</p>
<p>  $m_t$ 记录了梯度的平均，可以使算法根据历史梯度进行参数更新；$v_t$ 记录了梯度的平方平均，实质上是在考虑过滤了震荡后的历史梯度。因此 Adam 算法实现了根据历史梯度的震荡以及过滤了震荡后的历史梯度来对变量进行更新。</p>
<h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>损失函数度量了模型预测值与真是值的差距。</p>
<ul>
<li><p>交叉熵函数：$L(p,q)=-\sum_xp(x)\log q(x)$</p>
</li>
<li><p>均方误差损失函数：$MSE(y,\hat y)=\dfrac{1}{n}\sum_{i=1}^n(y_i-\hat y_i)^2$</p>
</li>
<li><p>距离损失函数，通过两个向量之间的距离来描述损失。这里的距离可以取多种距离，例如曼哈顿距离、欧氏距离、余弦相似度。</p>
</li>
</ul>
<p>我们本次建立的 CNN 如下：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\lab6\net.png) -->






<p>输入经过一个词嵌入层后输入卷积层，分别进行具有不同卷积核大小的卷积操作，得到的输出经过最大池化层得到输出，进入 dropout 层，通过一个线性层将输入映射为对应的分类。如果为了获取概率，我们可以对输出层做 softmax。设网络的第 i 个输出为 $W_i$，softmax 操作是指：<br>$$<br>p(y=i)=\dfrac{e^{W_i}}{\sum_{k=1}^N e^{W_k}}<br>$$<br>这样我们实现了归一化，并得到了样本被分为某一类的概率。</p>
<h3 id="关键代码展示"><a href="#关键代码展示" class="headerlink" title="关键代码展示"></a>关键代码展示</h3><p>使用逻辑回归，进行自训练算法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxiter):</span><br><span class="line">    <span class="comment"># if all texts are pseudo-labeled</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>(labeled) == <span class="built_in">len</span>(labeled):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Training over.&quot;</span>)</span><br><span class="line">        X_vec = vectorizer.transform(traintexts)</span><br><span class="line">        y_pred = model.predict(X_vec)</span><br><span class="line">        acc = accuracy_score(trainlabels, y_pred)</span><br><span class="line">        f1 = f1_score(trainlabels, y_pred, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Final accuracy: <span class="subst">&#123;acc&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Final f1: <span class="subst">&#123;f1&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># take keywords as the initial training set</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        X_new = keywords.copy()</span><br><span class="line">        y_new = y_train.copy()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Iteration <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># predict for all texts</span></span><br><span class="line">    X_vec = vectorizer.transform(traintexts)</span><br><span class="line">    y_pred = model.predict(X_vec)</span><br><span class="line">    prob = model.predict_proba(X_vec)</span><br><span class="line">    acc = accuracy_score(trainlabels, y_pred)</span><br><span class="line">    f1 = f1_score(trainlabels, y_pred, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(acc)</span></span><br><span class="line">    <span class="comment"># print(f1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># take M samples with max prob    </span></span><br><span class="line">    sorted_indices = <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(prob)), key=<span class="keyword">lambda</span> i : <span class="built_in">max</span>(prob[i]) * (<span class="number">1</span> - labeled[i]), reverse=<span class="literal">True</span>)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="comment"># add M samples into training set</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> sorted_indices[:M]:</span><br><span class="line">        <span class="keyword">if</span> labeled[j]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        X_new.append(traintexts[j])</span><br><span class="line">        labeled[j] = <span class="number">1</span></span><br><span class="line">        y_new.append(y_pred[j])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># train with new training set</span></span><br><span class="line">    X_new_vec = vectorizer.fit_transform(X_new)</span><br><span class="line">    model.fit(X_new_vec, y_new)</span><br><span class="line">    M += K</span><br></pre></td></tr></table></figure>

<p>我们每次迭代时，都取上一次迭代得到的分类器对所有的文本进行预测，取其中置信度最高的一些加入训练集，同时我们也需要保证训练集中的数据不会有重复的，因此我们开一个列表来标记所有放入训练集中的文本。当所有的文本都进入训练集时，我们结束训练。</p>
<p>使用 CNN 的逻辑也是差不多的，但是我们需要使用不同的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">model, dataloader, device, ts, ls, labeled, trLabels</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Select M samples and add them to training set. Return a new trainloader and accuracy.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># ts: all texts</span></span><br><span class="line">    <span class="comment"># trLabels: all labels</span></span><br><span class="line">    <span class="comment"># labeled: a list with zeros initialy</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    proba = []</span><br><span class="line">    traintexts = []</span><br><span class="line">    trainlabels = []</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    predicts = []</span><br><span class="line">    <span class="comment"># predict for all texts</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> dataloader:</span><br><span class="line">            <span class="comment"># print(dataloader[0])</span></span><br><span class="line">            inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line"></span><br><span class="line">            probs = F.softmax(outputs, dim=<span class="number">1</span>)</span><br><span class="line">            predictedProba, predictedLabel = torch.<span class="built_in">max</span>(probs, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            correct += (predictedLabel == labels.squeeze()).<span class="built_in">sum</span>().item()</span><br><span class="line">            proba += predictedProba.tolist()</span><br><span class="line">            predicts += predictedLabel.tolist()</span><br><span class="line">            </span><br><span class="line">    preLabels = [label2id[p] <span class="keyword">for</span> p <span class="keyword">in</span> predicts]</span><br><span class="line">    test_acc = correct / <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># take M samples</span></span><br><span class="line">    sorted_indices = <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(proba)), key=<span class="keyword">lambda</span> i:proba[i]*(<span class="number">1</span>-labeled[i]), reverse=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add into training set</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sorted_indices[:M]:</span><br><span class="line">        <span class="keyword">if</span> labeled[i]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        traintexts.append(ts[i])</span><br><span class="line">        trainlabels.append(preLabels[i])</span><br><span class="line">        labeled[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get new trainloader</span></span><br><span class="line">    newTrainSet = DatasetMaper(traintexts, trainlabels, word2id)</span><br><span class="line">    newTrainLoader = DataLoader(newTrainSet, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> newTrainLoader, test_acc</span><br></pre></td></tr></table></figure>



<h4 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h4><ol>
<li>在从关键词得到文本的伪标签时，尝试将关键词作为文本向量初始化分类器，对所有文本进行伪标记，取出其中置信度较高的作为初始的训练集。但最后从结果来看，这个方法与我们提到的其他方案在效果上区别不大。</li>
<li>在扩展训练集时，尝试在训练集增大的同时去增大加入训练集的样本个数，在一定程度上缓解了模型准确率随着自训练的进行而下降的现象。</li>
</ol>
<h2 id="实验结果与展示"><a href="#实验结果与展示" class="headerlink" title="实验结果与展示"></a>实验结果与展示</h2><h3 id="自训练算法-1"><a href="#自训练算法-1" class="headerlink" title="自训练算法"></a>自训练算法</h3><p>在这里，我们主要调整的参数就是以上代码中的 M 和 K，也就是等差数列的首项与公差。</p>
<p>首先可以观察训练集。在 20ns 中，我们要实现的是一个 20 分类任务，训练集中共有 18314 个文本，文本的分布是不均匀的。而在 agnews 中，我们需要实现 4 分类任务，训练集中共有 40000 个文本，文本的分布是均匀的。</p>
<p>第一步，我们需要生成伪标签。使用之前提到的方案 2，对 20ns 标记结果如下：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pse2.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse2.png" class="" title="这是一张图片">

<p>对 agnews 标记结果如下：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pse1.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse1.png" class="" title="这是一张图片">

<p>我们尝试方案三，并只看在方案二中获得了伪标签的那些文本（也就是包含关键词的文本），混淆矩阵如下：</p>
<p>20ns：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pse3.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse3.png" class="" title="这是一张图片">

<p>agnews：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pse4.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pse4.png" class="" title="这是一张图片">

<p>如果将所有文本都考虑进来，几乎所有不含关键词的文本都会被预测为某一类，这是由 Bag-of-Words/Tfidf 向量的特性决定的。对所有文本的结果如下：</p>
<p>20ns：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pseall1.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pseall1.png" class="" title="这是一张图片">



<p>agnews：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\pseall2.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/pseall2.png" class="" title="这是一张图片">

<p>我们还可以从生成伪标签这一步中看出，在 20ns 中包含关键词的文本是较多的，在 agnews 中包含关键词的文本是较少的。再加上两个训练集的大小不同，我们扩展训练集时当然不能对两个训练集一视同仁，而是要分别寻找合适的扩展个数与次数。</p>
<p>使用<strong>逻辑回归</strong>：</p>
<ul>
<li>我们首先生成伪标签，具体做法是采用之前提到的方案三，也就是直接用关键词作为词向量训练分类器，然后用这个分类器去对所有的文本进行标记，在其中取出 M 个置信度较高的。</li>
<li>对 20ns，取 M = 6000，K = 6000。</li>
<li>对 agnews，取 M = 4500，K = 5500。</li>
<li>Bag-of-Words模型，在20ns上准确率为 <strong>0.4866</strong>，f1_score为 <strong>0.4759</strong>（M = 4500, K = 4000）；在 agnews 上准确率为 <strong>0.7218</strong>，f1_score为 <strong>0.7126</strong>。</li>
<li>Tfidf模型，在20ns上准确率为 <strong>0.5717</strong>，f1_score为<strong>0.5411</strong>（M = 6000, K = 6000）；在agnews上准确率为<strong>0.7250</strong>，f1_score为<strong>0.6965</strong>。</li>
</ul>
<p>我们使用 Tfidf 时的混淆矩阵分别如下：</p>
<p>20ns：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\mata.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mata.png" class="" title="这是一张图片">

<p>agnews：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\matb.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/matb.png" class="" title="这是一张图片">



<p>下面我们对结果进行分析：</p>
<ul>
<li><p>模型在每个类上的准确率相当不均衡。以 agnews 为例，其在第 2 类上只有 26.13% 的准确率，而其他三类都达到了 80% 以上。然而在使用 Bag-of-Words 时，这个现象相对没有那么明显，如下图：</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\matcnt.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/matcnt.png" class="" title="这是一张图片"></li>
</ul>
<ul>
<li>在 20 分类任务中，这种不均衡带来对准确率的影响时要比 4 分类任务要小的。</li>
<li>我们在初始利用关键词生成伪标签时，准确率分别为 61.20% 与 79.06%。整体上来看，模型最终的准确率接近这两个值，可以说明我们自训练过程的合理性。</li>
<li>我们期望在自训练过程中，准确率是能够逐步上升的，想要做到这一点就需要精确控制我们每次迭代加入训练集的数据个数。即使经过了调参，模型在最后一步增加训练集时还是出现了准确率下降的现象。笔者对此的解释是，我们终止的条件是所有数据都被加入了训练集，最后加入的数据可能预测错误的样本数相对较多。但在此之前，我们的准确率都是稳步上升的。</li>
</ul>
<p>使用 CNN：</p>
<ul>
<li>在 20ns 上准确率为 48.29%</li>
<li>在 agnews 上准确率为 69.95%</li>
</ul>
<p>似乎 CNN 在这个任务中的表现还不如更为简单的逻辑回归。但这可能是因为我还没有花很多的时间去调参，甚至有可能是因为迭代的次数不够。</p>
<h3 id="未知类别识别"><a href="#未知类别识别" class="headerlink" title="未知类别识别"></a>未知类别识别</h3><p>这里我们使用的策略是基于置信度的拒绝。我们还是按照之前的自训练方法进行训练，将预测置信度低于某个阈值的文本预测为未知类别。</p>
<p>首先看这个方法在 agnews 上的结果。我们迭代 4 次停止训练，得到的准确率为 <strong>0.5908</strong>，f1_score 为 <strong>0.5816</strong>。如果我们不进行未知类别识别，准确率为 <strong>0.5711</strong>，未知类型识别带来了接近 2% 的提升。</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\mat2_unk.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mat2_unk.png" class="" title="这是一张图片">



<p>在 20ns 上，准确率为 <strong>0.4921</strong>，f1_score 为 <strong>0.4986</strong>。如果不进行未知类别识别，准确率为 <strong>0.4838</strong>。</p>
<!-- ![](D:\桌面\大二下\Artificial Intelligence\hw\project\mat1_unk.png) -->
<img src="/2023/07/11/%E5%BC%B1%E7%9B%91%E7%9D%A3%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/mat1_unk.png" class="" title="这是一张图片">

<p>观察混淆矩阵，未知类别的召回率和精确率都不是很高，另外在前面提到的准确率不均衡的问题也仍然存在。总体来说，在未知类型识别任务上，此模型表现不是很好。我有一些继续优化模型的想法，但由于时间关系没有去尝试：</p>
<ul>
<li>使用复杂度更高的模型，如 CNN。</li>
<li>在将数据加入训练集时，考虑将某些预测置信度低的样本标记为未知类别，一并加入训练集。</li>
<li>进一步调整阈值。如果阈值过小，会导致未知类别预测的召回率过低；如果阈值过大，会导致未知类别的精确率过低。找到一个合适的阈值是这个任务中比较困难的一个环节。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349107869">半监督学习 - 知乎 (zhihu.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://ai.stanford.edu/blog/understanding-self-training/">Understanding Deep Learning Algorithms that Leverage Unlabeled Data, partial 1: Self-training | SAIL Blog (stanford.edu)</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/21/Pell%E6%96%B9%E7%A8%8B/" rel="prev" title="Pell方程">
                  <i class="fa fa-chevron-left"></i> Pell方程
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Megaee</span>
</div>

    </div>
  </footer>
  <script src="/live2d-widget-master/live2d-widget-master/autoload.js"></script>
  
  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
